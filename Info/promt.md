# МАСТЕР-ПРОМПТ ДЛЯ CODEX-5.1  
## Учебный проект OTUS: система бронирования отелей (микросервисы на .NET)

### 0. Роль и стиль

Выступай в роли **ведущего .NET архитектора/сеньор-разработчика**, который проектирует и описывает учебную систему бронирования отелей для студентов OTUS.

Требования к стилю:

- Пиши **по-русски**, техническим, но понятным языком.
- Никаких фраз про ИИ, модели, подсказки, промпты и т.п. Пиши так, как будто это результат обычной архитектурной работы опытного разработчика.
- Текст должен выглядеть как **ручная документация разработчика**, а не как маркетинговая презентация.
- Уважай уровень студентов: предполагаем мидл .NET-разработчиков, знакомых с REST, HTTP, SQL, basics по RabbitMQ.
- Не используй «магические» сокращения без расшифровки. Если вводишь термин, сначала коротко объясни его.

---

### 1. Цель документа

Сформировать **полное, самодостаточное текстовое описание** учебной системы бронирования отелей, по которому студенты смогут:

1. Понять бизнес-процессы (как происходит бронирование, заселение, выезд, отмена).
2. Понять общую архитектуру микросервисов и их границы ответственности.
3. Разобраться, какие есть **базы данных**, какие таблицы в каких сервисах, какие связи и ограничения.
4. Понять контракты REST API каждого сервиса: основные эндпоинты, модели запросов/ответов, коды ошибок.
5. Понять механизм обмена сообщениями через RabbitMQ: какие события публикуются и кем, кто на них подписывается.
6. Увидеть **типовые сценарии** (use cases) от лица:
   - гостя (Customer),
   - менеджера (Manager),
   - администратора (Admin).
7. Получить список **учебных заданий**, которые они смогут реализовать на основе описанной архитектуры.

Документ должен быть написан так, чтобы, прочитав его, студент мог **самостоятельно реализовать сервисы**, не задавая дополнительных вопросов по архитектуре.

---

### 2. Технологический стек и допущения

Сразу в начале документа явно опиши:

- **Язык и платформа:** .NET 8, C# 12.
- **Стиль архитектуры:** микросервисы, REST API, асинхронный обмен сообщениями через RabbitMQ.
- **API Gateway:** Ocelot.
- **Хранилища данных:** реляционные БД (допущение: PostgreSQL). Для Identity можно использовать стандартную схему ASP.NET Identity.
- **Аутентификация и авторизация:** JWT-токены, роли `Customer`, `Manager`, `Admin`.
- **Область проекта:** учебная система для одного (или нескольких) отелей, без сложного динамического ценообразования и без полноценной интеграции с платежными провайдерами.
- **Ограничения:** невысокий трафик, учебная среда, поэтому предпочтительнее простые, но наглядные решения.

Отдельно перечисли **что мы сознательно упрощаем** (нет реальных платежей, нет интеграции с OTA/Booking.com и т.п.).

---

### 3. Высокоуровневый обзор системы

Сделай раздел:

#### 3.1. Основные роли и их сценарии

Опиши в виде под-подразделов:

- **Роль Customer (гость)**:
  - Поиск отеля по городу/датам.
  - Просмотр доступных номеров и цен.
  - Создание брони.
  - Просмотр списка своих броней, отмена (если это разрешено правилами).
- **Роль Manager (менеджер отеля)**:
  - Просмотр списка заездов/выездов на выбранную дату.
  - Операции check-in/check-out.
  - Ручная правка брони (например, смена номера, изменение дат при наличии свободных номеров).
- **Роль Admin (админ/владелец сети)**:
  - Создание/редактирование отелей.
  - Управление номерами, типами номеров и базовыми тарифами.
  - Управление пользователями и их ролями (назначение менеджеров на отели).
  - Настройка общесистемных параметров (например, сколько часов держать неоплаченную бронь).

#### 3.2. UI-слой

Коротко опиши три фронта:

- **Customer UI** — публичный фронт для клиентов.
- **Manager UI** — внутренний интерфейс по защищённому доступу (может быть отдельным SPA).
- **Admin UI** — административная панель.

Отметь, что **все три UI обращаются только к API Gateway**, не ходят напрямую к микросервисам.

#### 3.3. API Gateway

Опиши:

- Почему выбран **API Gateway на Ocelot**.
- Какие типы задач он решает:
  - маршрутизация запросов к нужным сервисам;
  - проброс аутентификации/авторизации;
  - унификация префиксов URL;
  - при желании — логирование и простая трансформация ответов.

---

### 4. Список микросервисов и их границы ответственности

Сделай отдельный раздел **«Архитектура микросервисов»** и в нём подпункты по каждому сервису:

#### 4.1. IdentityService (Auth.Api)

- Ответственность:
  - регистрация пользователей;
  - авторизация (логин);
  - выдача и обновление JWT;
  - управление ролями.
- Основные сущности:
  - `User`, `Role`, `UserRole`, `RefreshToken` (можно указать, что используем стандартную модель ASP.NET Identity).
- Связь с другими сервисами:
  - CustomerService хранит свой `CustomerProfile`, связанный с `UserId` из Identity.
- Основные эндпоинты:
  - `POST /api/auth/register`
  - `POST /api/auth/login`
  - `POST /api/auth/refresh`
  - `GET  /api/auth/me`

#### 4.2. CustomerService (Customer.Api)

- Ответственность:
  - расширенный профиль клиента (ФИО, контакты, предпочтения).
- Основная сущность:
  - `CustomerProfile`: Id, UserId, FullName, Email, Phone, Preferences, CreatedAt, UpdatedAt.
- Основные операции:
  - получение/обновление профиля текущего пользователя;
  - поиск клиента по Id для менеджерских сценариев.

#### 4.3. HotelService (Hotel.Api)

- Ответственность:
  - справочник отелей и номерного фонда;
  - хранение базовых цен и простых сезонных коэффициентов.
- Основные сущности:
  - `Hotel` (Id, Name, Address, Description, Timezone, CheckInTime, CheckOutTime, …);
  - `RoomType` (Id, HotelId, Name, Capacity, Description, AmenitiesJson);
  - `Room` (Id, HotelId, RoomTypeId, RoomNumber, Floor, Status);
  - `RatePlan` (Id, HotelId, RoomTypeId, Name, BasePrice, Currency, CancellationPolicyType, …);
  - `SeasonPrice` (Id, HotelId, RoomTypeId, DateFrom, DateTo, PriceOverride/Multiplier).
- Основные операции:
  - CRUD для отелей, типов номеров, номеров, тарифов (для Admin/Manager);
  - выдача списка отелей и их номерного фонда для Customer UI (только чтение).

#### 4.4. ReservationService (Reserve.Api)

- Это основной домен бронирований.
- Ответственность:
  - приём запросов на создание/изменение/отмену брони;
  - проверка доступности номеров;
  - хранение брони и её статуса;
  - разбиение бронирования по дням и номерам для контроля овербукинга.
- Основные сущности:
  - `Reservation`:
    - Id, CustomerId, HotelId, Status (Draft, Booked, CheckedIn, CheckedOut, Cancelled, NoShow),
    - CheckInDate, CheckOutDate,
    - GuestsCount,
    - TotalPrice, Currency,
    - CreatedAt, UpdatedAt.
  - `ReservationRoom`:
    - Id, ReservationId, RoomId, StayDate.
    - Обязательно указать, что в БД на `(RoomId, StayDate)` есть уникальный индекс.
- Основные операции:
  - `POST /api/reservations` — создать бронь;
  - `GET /api/reservations/{id}` — получить бронь;
  - `GET /api/reservations/my` — список броней текущего клиента;
  - `POST /api/reservations/{id}/cancel` — отмена;
  - `POST /api/reservations/{id}/check-in` — заселение;
  - `POST /api/reservations/{id}/check-out` — выезд.
- Важный блок: **как реализуем проверку доступности**:
  - в процессе создания брони выбираем подходящие номера (по RoomType/количеству гостей) из HotelService;
  - вставляем строки в `ReservationRoom` по каждому дню проживания;
  - если получаем конфликт уникального индекса — считаем, что номер уже занят на эту дату, возвращаем ошибку «Нет доступных номеров».

#### 4.5. AdminService (Admin.Api)

- Ответственность:
  - единая точка управления системой для роли Admin.
- Особенности:
  - сам по себе может иметь минимальную БД (глобальные настройки),
  - большую часть данных отдаёт за счёт обращений к другим сервисам через REST.
- Примеры операций:
  - агрегированный список отелей с краткой статистикой по бронированиям;
  - управление пользователями и ролями (можно реализовать как прослойку над IdentityService).

#### 4.6. SchedulerService (Scheduler.Api / Scheduler.Worker)

- Ответственность:
  - хранение задач (job-ов) и их выполнение по расписанию.
- Основная сущность:
  - `ScheduledJob`:
    - Id, Type (например: SendCheckInReminder, AutoCancelUnpaid, MarkNoShow),
    - Payload (JSON с нужными идентификаторами),
    - ExecuteAt (UTC-время),
    - Status (Pending, InProgress, Completed, Failed),
    - RetryCount, LastError.
- Поведение:
  - При создании брони `ReservationCreated` → система создаёт:
    - задачу `SendCheckInReminder` за 24 часа до `CheckInDate`,
    - задачу `MarkNoShow` на определённое время вечера дня заезда.
  - Планировщик периодически (каждую минуту) выбирает именно свои *pending* задачи, срок которых наступил, отмечает их InProgress, публикует соответствующие сообщения в RabbitMQ и помечает как Completed/Failed.
- Важно описать **идемпотентность** и базовый механизм ретраев (чтобы повторная обработка задания не создавала дубликатов).

#### 4.7. NotificationService (Notification.Api)

- Ответственность:
  - отправка email и сообщений в Telegram-бота по событиям.
- Основные сущности:
  - `NotificationTemplate` (Id, Type, Channel, Subject, BodyTemplate, Locale);
  - `OutgoingMessage` (Id, Type, Channel, Recipient, PayloadJson, Status, LastError, SentAt).
- Подписка на события:
  - `ReservationCreated` → «Подтверждение брони»;
  - `ReminderDue` → «Напоминание о заезде»;
  - `ReservationCancelled` → «Уведомление об отмене».
- Реализация канала:
  - в рамках учебного проекта достаточно описать простую SMTP-интеграцию и вызов Telegram Bot API; реальные креды и конфиги следует вынести в настройки.

---

### 5. Межсервисное взаимодействие и RabbitMQ

Сделай отдельный раздел, где:

1. Описываешь общую схему:

   - Основной способ обращения фронтов к бэку — **HTTP через API Gateway**.
   - Межсервисные асинхронные взаимодействия — **через RabbitMQ**.
   - Можно указать пример: exchange `hotel.reservation.events` (тип fanout или topic), очереди по сервисам.

2. Приводишь таблицу событий:

   - Столбцы: «Событие», «Кто публикует», «Кто подписан», «Назначение», «Важные поля».
   - Примеры:
     - `ReservationCreated`
       - Публикует: ReservationService.
       - Подписаны: SchedulerService (создаёт задания), NotificationService (шлёт подтверждение).
       - Поля: ReservationId, CustomerId, HotelId, CheckInDate, CheckOutDate, TotalPrice.
     - `ReservationCancelled`
       - Публикует: ReservationService.
       - Подписаны: SchedulerService (отменяет задания), NotificationService.
     - `ReminderDue`
       - Публикует: SchedulerService.
       - Подписан: NotificationService.

3. Описываешь **базовый паттерн обработки сообщений**:

   - обязательная корреляция по Id брони;
   - обработчики должны быть идемпотентны (повторная обработка одного и того же сообщения не приводит к дублированию уведомлений/заданий).

---

### 6. Базы данных и схемы (ER-диаграммы и описания таблиц)

Сделай для каждого сервиса, имеющего свою БД, отдельный подпункт.

#### 6.1. Общие правила

Сначала коротко опиши общий подход:

- У каждого микросервиса **своя БД/схема**.
- Межсервисные связи только по ID (никаких foreign key между БД разных сервисов).
- Обязательны поля аудита: `CreatedAt`, `UpdatedAt`, при необходимости `CreatedBy`, `UpdatedBy`.

#### 6.2. Схема Identity

Можно коротко сослаться на стандартные таблицы ASP.NET Identity, но всё же перечислить ключевые:

- `AspNetUsers`, `AspNetRoles`, `AspNetUserRoles`, `AspNetUserTokens`, `AspNetRefreshTokens` (если используем отдельную таблицу).

#### 6.3. Схема Customer

Опиши таблицу `CustomerProfiles` с полным набором полей и соответствующими типами (для PostgreSQL).

#### 6.4. Схема Hotel

Приведи таблицы:

- `Hotels`
- `RoomTypes`
- `Rooms`
- `RatePlans`
- `SeasonPrices`

Для каждой таблицы:

- перечисли поля (имя, тип, назначение),
- укажи ключи и индексы (например, индекс на `(HotelId, RoomTypeId)`).

#### 6.5. Схема Reservation

Приведи таблицы:

- `Reservations`
- `ReservationRooms`

Важный момент:

- явно укажи **уникальный индекс** на `(RoomId, StayDate)` в `ReservationRooms` и объясни, что он используется для борьбы с двойными бронированиями.

#### 6.6. Схема Scheduler

Таблица `ScheduledJobs` с полями, описанными выше.

#### 6.7. Схема Notification

Таблицы:

- `NotificationTemplates`
- `OutgoingMessages`

При необходимости можно добавить простую таблицу `NotificationChannelsSettings` (конфиги SMTP/Telegram), но можно ограничиться описанием конфигурации в settings.

---

### 7. REST API: контракты для основных сценариев

Сделай раздел с основными сценариями (use cases) и опиши **конкретные HTTP-контракты**:

- Для каждого сценария:
  - шаги;
  - какие эндпоинты вызываются в каком порядке;
  - примеры JSON запросов/ответов;
  - типичные коды ответа и ошибки.

#### 7.1. Создание брони пользователем

Пример сценария:

1. Customer выбирает отель и даты в UI.
2. UI вызывает через Gateway:
   - `GET /api/hotels/{hotelId}/availability?checkIn=...&checkOut=...&guests=...`
     - эндпоинт HotelService/ReservationService, который возвращает доступные типы номеров и цены.
3. Пользователь выбирает конкретное предложение → UI вызывает:
   - `POST /api/reservations`
     - тело запроса: HotelId, CheckInDate, CheckOutDate, GuestsCount, RoomTypeId/RatePlanId.
4. ReservationService создаёт бронь, пытается забронировать номер(а) через вставку в `ReservationRooms`.
5. В случае успешного бронирования возвращается `201 Created` с деталями резервации.
6. В случае конфликта по уникальному индексу → `409 Conflict` с кодом ошибки `NoAvailableRooms`.

Приведи пример тела запроса и ответа.

#### 7.2. Отмена брони

Опиши:

- `POST /api/reservations/{id}/cancel`
- Проверки:
  - статус брони (нельзя отменить уже завершённую/отменённую);
  - политика отмены (можно сильно упростить).
- Снятие записей `ReservationRooms`, чтобы освободить номер.

#### 7.3. Процессы check-in/check-out для менеджера

Приведи:

- `GET /api/manager/reservations/arrivals?date=...` — список ожидаемых заездов.
- `POST /api/manager/reservations/{id}/check-in`
- `POST /api/manager/reservations/{id}/check-out`

Опиши, какие статусы меняются и какие события публикуются.

---

### 8. Планировщик: сценарии и тайминги

Сделай небольшой раздел, где:

- перечислены типы задач планировщика;
- описаны **параметры, которые будут настраиваемыми** (например, число часов до напоминания, число часов до выставления статуса NoShow);
- описан механизм, как планировщик реагирует на отмену брони (удаляет/деактивирует связанные ScheduledJobs).

---

### 9. Уведомления: шаблоны и формирование сообщений

- Приведи примеры 2–3 шаблонов:

  - «Подтверждение брони»;
  - «Напоминание о заселении»;
  - «Уведомление об отмене брони».

- Покажи, какие данные нужны для подстановки (имя гостя, даты, название отеля, адрес, ссылка на бронь).
- Опиши, как NotificationService получает данные:
  - либо целиком из события, если оно содержит необходимую информацию;
  - либо, при необходимости, делает запрос в ReservationService/HotelService.

---

### 10. Нефункциональные требования: логирование, метрики, ошибки

Сделай короткий, но конкретный раздел:

- **Логирование:**
  - стандартный логгер ASP.NET + correlationId (например, `X-Correlation-ID`);
  - обязательно логировать ключевые бизнес-события (создание/отмена брони, отправка уведомления).
- **Метрики:**
  - сколько броней создаётся в единицу времени;
  - доля успешных/неуспешных попыток бронирования;
  - сколько уведомлений отправлено/ошибок.
- **Обработка ошибок:**
  - конвертация доменных ошибок в HTTP-ответы (400/404/409);
  - ретраи при временных проблемах с внешними ресурсами (SMTP/Telegram/RabbitMQ).

---

### 11. Учебные задания для студентов

Сделай завершающий раздел, в котором:

1. Опишешь **базовый обязательный минимум**:
   - поднять локально API Gateway, IdentityService, HotelService, ReservationService;
   - реализовать ключевые таблицы БД и миграции;
   - реализовать сценарий создания/отмены брони с защитой от двойного бронирования.

2. Опишешь **задачи повышенной сложности**:
   - внедрить SchedulerService и NotificationService;
   - реализовать отправку email/Telegram-уведомлений;
   - добавить дополнительные статусы и бизнес-правила (например, NoShow);
   - добавить простую политику отмены (бесплатно до Х часов до заезда).

3. Укажешь **возможные направления расширения**:
   - полноценный сервис платежей;
   - интеграция с внешними каналами продаж;
   - динамическое ценообразование.

---

### 12. Требования к формату выходного документа

- Выводи **один большой Markdown-документ**, хорошо структурированный по разделам и подпунктам.
- Используй заголовки `#`, `##`, `###` и нумерованные/маркированные списки.
- Можно включать простые ER-диаграммы и схемы взаимодействия в формате Mermaid (например, `erDiagram`, `sequenceDiagram`).
- Не добавляй в текст ничего про ChatGPT, LLM, модели, промпты, агентов.
- Пиши так, как будто это итоговая архитектурная документация, которую старший разработчик подготовил для учебного курса OTUS.

На этом требования заканчиваются. Сгенерируй полный документ, строго соблюдая структуру и наполнение, описанные выше.
